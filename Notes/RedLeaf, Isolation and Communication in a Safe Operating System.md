## RedLeaf: Isolation and Communication in a Safe Operating System

### Purpose
- 系统隔离机制（在子系统崩溃时应该：）
	- 回收子系统使用的所有资源；
	- 保留由子系统分配但随后通过通信通道传递给其他子系统的对象；
	- 确保终止的子系统所公开的接口的所有未来调用不会违反安全性或阻塞调用者，而是返回错误。

### Design

- 基于语言的*隔离域*的抽象（信息隐藏、加载程序、故障隔离）；
	- ***堆*隔离**：域从不持有指向其他域私有堆的指针。
		- *堆*：
			- 每个域有独自的堆（由语言性质保护）），
			- 存在一个*共享堆*实现域间通信。
				- `RRef<T>`用于引用共享堆中的数据（即其中的元数据（元数据部分记录了所有者域的信息以及在跨域调用中不可变地借用次数）和值都在共享堆上）；
			- 微内核有*堆注册表*（微内核为域提供一种在共享堆上分配未分类的粗粒度内存区域（大于一个页面）的接口，在注册时记录域使用的堆）；
		- **可交换类型**：（共享堆上只有*可交换类型对象*）可以在域之间安全地交换的类型，而不会泄漏指向私有堆的指针；
			- 在共享堆上分配的对象不能有指向私有域堆的指针，但可以引用共享堆上的其他对象。
		- **拥有权跟踪**：为了在共享堆上释放崩溃域拥有的资源，我们跟踪共享堆上的所有对象的拥有权；
			- 当域在跨域函数调用中传递对*共享对象的引用*时，域失去对该对象的所有权。
	- **接口验证**：开发了一种接口定义语言（IDL），静态验证跨域接口的定义并为它们生成实现。（验证所有跨域接口，实施接口只能使用可交换类型的不变量）
		- **跨域调用代理**：我们通过调用代理（在所有跨域接口中介一层代码）来调解所有跨域调用——一层可信代码，介入所有域的接口。（为从崩溃的域中回退执行提供支持，并阻止未来的调用）

![](C:\Users\k\Desktop\reference fold\Notes\imgs\RedLeaf\arch.png)

> - **隔离域**
> 	- 域接收*微内核系统调用接口*为创建的一部分，这是域影响系统的其余部分的唯一权限（接口）。
> 		- 微内核跟踪为每个域创建的所有资源：分配的内存、注册的中断线程等；
> 		- 线程可以在*创建它的域之外*存在，它们进入其他域后在那里可以无限期地运行（即使*创建它的域*奔溃）；
> 	- 每个域都可以从微内核调用的`init`函数中创建线程。
> 	
> - *故障隔离*
> 	- *故障*：当进入某个域的线程之一发生崩溃并需要终止时，我们说该域崩溃了。
> 	- *故障*被隔离：
> 		- 将所有在崩溃域内运行的*线程*退回到域入口点，并向调用者返回错误；
> 		- 后续尝试*调用*该域会返回错误，但不会违反安全保证或导致崩溃；
> 		- 安全地释放崩溃域的所有资源（即其他域不持有对崩溃域堆的引用，并且可以回收该域拥有的所有资源而不会泄漏）；
> 		- 在其他域中的线程继续执行（它属于其他域了），并且可以继续访问由崩溃域分配但在崩溃之前移动到*线程运行所在域*的对象（对象也属于其他域了）；

![](C:\Users\k\Desktop\reference fold\Notes\imgs\RedLeaf\communication.png)

- 跨域调用（共享堆对象所有权跟踪）：
	- 参数只能是共享堆中的对象；
		- 共享堆中的对象包括`根RRef<T>`（有dom_id， X）和`子RRef<T>`（没有dom_id），`根RRef<T>`负责`子RRef<T>`的释放； 
	- 跨域调用使用*代理*进行中介（代理负责处理共享堆中对象的所有权）；
	- 微内核拥有的*堆注册表*负责回收*崩溃域拥有的共享堆对象*；

- *代理（Proxy）*
	- 代理在执行调用前检查域是否存活。
	- 对于每个调用，代理创建一个轻量级的连续体（continuation），捕获线程在跨域调用之前的状态。
		- 微内核存储着*连续体栈*；
		- 当要解绑线程时，恢复线程状态并在其中处理异常；
			- 解绑（Unwinding）：Rust中线程奔溃（panic）时表现为：所有函数瞬间返回并析构对象。
	- 代理在域之间传递所有传递的 RRef<T> 的所有权。
	- 代理包装所有作为参数传递的特征引用：代理为每个特征创建一个新的代理，并将引用传递给由该代理实现的特征。