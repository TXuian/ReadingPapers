### L4 Family
1. L3：由Liedtke [1993b]在1980年代初在i386平台上开发而来。
2. L4：是在L3的基础上发展而来的，最初在i486-based PC上由Liedtke完全使用汇编语言实现，后来还被移植到了Pentium上。
3. Fiasco：是德累斯顿从头开始实现的新版本，在x86平台上使用C++语言编写。
4. Hazelnut：由Liedtke和他的学生们从头开始实现的内核，使用C语言编写，并且是第一个将L4内核移植（而不是重新实现）到另一个架构（从Pentium到ARM）的内核。
5. L4Ka::Pistachio：由Liedtke的学生们在他去世后，使用C++语言重新实现的版本，最初在x86和PowerPC上实现，后来被移植到了其他架构上。
6. OKL4 microkernel：由Open Kernel Labs接管L4Ka::Pistachio，在其基础上进行了进一步的开发和支持。
7. PikeOS：由Sysgo推出的商业版L4内核，是V2版的克隆版本，获得了安全关键的航空电子学的认证，并在飞机和列车上部署。
8. seL4：是由NICTA从头开始实现的基于能力的L4内核，旨在实现形式化验证。

> seL4（最初是为支持关于安全性和安全性的形式推理而设计的，同时保持L4的最小性、性能和支持几乎任意系统架构的能力） 
> Fiasco（经历了大部分L4历史的代码库）
> NOVA（为x86平台上的硬件支持的虚拟化而设计）
> OKL4（它被设计为在ARM处理器上有效地实现para-virtualization的商业平台）
> 

## 微内核设计

> - 微内核源于*最小化原则*与*IPC性能*

- **最小化原则（核心设计原则）**：只有在将其移出内核，即允许竞争实现，会阻止系统所需功能的实现时，才会容忍概念存在于µ-kernel内。

#### IPC
#### 同步IPC
- *同步IPC*：同步IPC是指进程之间进行通信时，必须等待另一个进程响应并返回结果后才能继续执行。
	- 它是一种阻塞式的通信方式，需要显式地进行同步和互斥处理。
	- 在同步IPC中，发送进程会等待接收进程的响应，直到接收进程完成操作并返回响应后，发送进程才能继续执行。
	- 同步IPC避免了内核缓冲和与之相关的管理和复制成本，但也可能导致同步复杂性增加。

- seL4中的*异步端点（AEPs）*
	- 逻辑上，异步端点类似于在单个字中分配的多个二进制信号量：每个AEP都有一个单字通知字段。
	- 等待操作相当于在通知字段上执行select()。

> - select()/poll()：（1）等待一群文件的变化，（2）当中间有文件发生状态变化就返回，（3）由使用者轮询文件集合找到变化的文件。

#### 消息结构
- 原始的L4 IPC语义：支持传递任意大小的消息；
- NOVA，Fiasco，seL4，OKL4：不支持长消息；

> - OKL4面向存储有限的嵌入式设备；

