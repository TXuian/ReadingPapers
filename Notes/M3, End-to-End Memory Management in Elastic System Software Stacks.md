## M3: End-to-End Memory Management in Elastic System Software Stacks

#### Problem（Motivation）：最佳分配内存资源给*弹性应用程序*以最大化整体性能

> - 传统的工作集理论预测，给予应用程序比其工作集更多的内存不会提高性能，但是内存减少时性能会急剧下降。
> - 像*数据分析框架*或*缓存*等应用程序可以使用各种内存大小运行相同的工作负载。
>   - 它们的性能随着内存数量的增加而不断提高；
>   - 但在提供较少内存时仍会取得(降低的)进展。
> - 许多这些应用程序是构建在复杂的软件堆栈上的，每个层次都在独立地进行内存管理（App—Hadoop—Java VM—OS，每层都有各自的内存管理）。

- 数据分析工作负载的弹性
![](C:\Users\k\Desktop\reference fold\Notes\imgs\M3\Elasticity.png)

- 系统堆栈中的MM（内存管理）问题
	- *静态管理*（分配最大使用内存，当大部分时间分配的内存没有被用到）
	- *不透明的内存利用信息*（下层不知道上层的内存使用信息（如，JVM语言运行时将贪婪地使用其整个最大堆大小，然后再积极地执行GC。对于操作系统而言，这些内存看起来是在使用中，即使其中绝大部分是垃圾））
	- *不协调MM*（如，JVM如再Spark之前执行GC（即上层释放内存之前），将有较少的机会收回内存）

### Design Principle

- 端到端方法：M3采用端到端方法，最低层操作系统只在(物理)内存压力下向上层通知，留下如何、何时、以及分配和回收多少内存的决定，交由更高级别的应用程序处理。基本上，应用程序而不是操作系统处于最佳位置，可以做出这些决策。

- 动态适应：内存分配受到一个自适应分配协议的管理，M3中的每个应用程序都被修改以运行该协议。
	- 该协议有两个目标。
		- 第一个是在系统压力（当允许应用程序自由增长会导致抖动时）下减缓应用程序内存使用量的增长；
		- 第二个是基于每个应用程序的内存需求分配可用的内存资源。
	- 在M3下，内存分配不断地适应应用程序内存需求和系统内存可用性的变化。
		- 操作系统用来决定何时通知应用程序（应用使用了超过阈值的内存资源）的策略也是自适应的：我们提出了一种动态调整阈值的算法，而不是使用固定的内存压力阈值。

- 非侵入性：M3选择利用现有的机制，以便最小化部署障碍。由于弹性应用程序已经有内存回收机制，如GC，因此这是可能的。虽然应用程序仍需要修改以实现策略，但机制需要的修改很少。

### Design

![](C:\Users\k\Desktop\reference fold\Notes\imgs\M3\arch.png)

- Low Threshold Signal / High Threshold Signal：提醒*上层*内存稀缺/告急（由信号接收者决定怎么处理（执行轻量GC/完全GC））
	- 修改 JVM，在堆区域被释放（GC）时，使用 madvise 系统调用将内存返回给操作系统；
	- 修改 Go，一旦收集到堆区域（GC），就会使用 madvise 将其返回给操作系统；
	- M3 还要求层在完成回收时通知下面的层，以确保按正确顺序进行内存回收（如，程序调用触发GC的API（JVM 已经公开了用于应用程序触发 GC 的 API，但只能对整体 GC 进行操作。我们添加了另一个 API，以触发成本较低的增量 GC））。
	- 接收到信号后，各层执行的操作
	![](C:\Users\k\Desktop\reference fold\Notes\imgs\M3\policies.png)

- 自适应策略：$Allow\  rate = min(\frac{Time\  elapsed\  since\  last\  signal}{Epoch\  length \times NUM\_{epoches}}, 100\%)$，速率的值在[0，100％]的范围内。例如，如果这个速率是10％，那么只有10％的分配是允许的，其他的分配将被延迟。
	- 修改应用程序使用的分配函数（通常称为alloc()）来实现此协议。
		- 只允许第⌊1/r⌋个alloc()正常进行（其中r是允许速率）；
		- 否则先调用内存驱逐函数，以释放足够空间来满足该分配。
	- 对于大多数应用程序，分配内存的速度比回收内存的速度快，因此分配速率可能会超过并发回收速率。
	- 当接收到高阈值信号时，表明系统面临内存压力，我们需要减缓应用程序的分配速率，以避免内存耗尽。

- 监视器设计
	- （总内存使用量大于阈值时）将进程排序后，按顺序向进程发送信号。
		- 从最新到最旧（有利于批处理作业）；
		- 从最旧到最新（有利于交互式作业）；
		- 按内存使用量从大到小排序；
		- 按预期回收量从大到小排序。
	- 自适应阈值
		- 如果高阈值达到的频率高于预期，监视器应该降低低阈值。
		- 如果高阈值达到的频率低于预期，低阈值应该增加。

### Related Work

- 对比MemOpLight：
	- 设计原则不同：M3遵循端到端、动态适应和非侵入性三个设计原则，而MemOpLight则关注应用程序之间的内存资源分配策略，认识到应用程序对其性能特征有最理想的了解。
	- 应用场景不同：M3主要用于动态分配内存以适应运行在裸机内核上的弹性堆栈应用程序，而MemOpLight只处理两个层次的复杂软件堆栈，即内核和容器。
	- 内存管理策略不同：M3采用自适应分配协议对内存分配进行管理，并且操作系统用来决定何时通知应用程序的策略也是自适应的。而MemOpLight只是在应用程序之间分配策略，缺少自适应的内存分配策略。
	- 处理问题不同：M3处理动态分配内存以最大化整体性能的问题，而MemOpLight只关注避免资源耗尽的问题，不解决如何分配内存资源以最大化性能的问题。
	- 系统实现机制不同：M3在每个层次插入了一组机制和策略，以动态分配内存资源，而MemOpLight是通过应用程序发出信号让内核执行工作，只处理内核和容器两个层次的复杂软件堆栈。
